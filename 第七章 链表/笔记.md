# 7.1单向链表
单向链表最简单的实现形式就是由多个节点的集合共同构成一个线性序列。
每个节点含有两个成员：
- 元素成员：引用一个任意的对象。
- 指针域成员：指向单向链表的后继节点。

## 7.1.1使用单向链表实现栈

**代码见**`LinkedStack.py`

操作|运行时间
---|---
S.push(e)|O(1)
S.pop()|O(1)
S.top()|O(1)
len(S)|O(1)
S.is_empty()|O(1)

## 7.1.2 使用单向链表实现队列

**代码见**`LinkedQueue.py`

注意点：
1. 入队列时，需要考虑空队列的特殊情况，此时，队顶、队尾均指向该节点
2. 出队列时，需要考虑，出完之后变成空队列的特殊情况，此时，对尾应该为空

# 7.2 循环链表
在链表中，我们可以使用链表尾部节点的"next"指向链表的头部，由此来获得循环链表。

应用场景：轮转调度

注意点：同单向链表实现队列；

优点：可以快速的实现队首元素出队、再次入队的操作

**代码见**`CircularQueue.py`

# 7.3 双向链表

链表中的每个节点都维护了指向其前驱节点以及后继节点的引用，这样的链表被称为双向链表。

优点：支持更多的时间复杂度为O(1)的操作，包括在任意位置插入和删除节点。

**头哨兵和尾哨兵:**

在列表的起始位置添加头节点(header),在列表的结尾位置添加尾节点(tailer)。这些**不存储主序列的元素**的节点被称为哨兵。

优点：可以使用统一的方式处理所有的插入节点操作。

**双向链表基本类代码见**`_DoublyLinkedBase.py`

## 7.3.2 使用双向链表实现双端队列

# 7.4 位置列表的抽象数据类型
1. 使用整数索引并非一直都很合适
2. 直接使用节点来进行操作会违反了抽象和封装两个面向对象的设计原则

引入一个独立的位置抽象表示列表中一个元素的位置，而不是直接依赖于节点，进而引入一个可以封装双向链表的完整的含位置信息的列表ADT.

- why
- what

## 7.4.1 含位置信息的列表抽象数据结构
- p.element()
- L.first()
- L.last()
- L.before(p)
- L.is_empty()
- len(L)
- iter(L)
- L.add_first(e)
- L.add_last(e)
- L.add_before(p, e)
- L.add_after(p, e)
- L.replace(p, e)
- L.delete(p)

## 7.4.2 双向链表实现
命题 7-2：当使用双向链表实现时，位置列表ADT每个方法的运行时间为最坏情况O(1)

**基于双向链表位置列表 实现代码见**`PositionalList.py`


## 小结
1. 使用位置列表来提供更广泛的操作
2. 通过额外的position类来进行封装

# 7.5 位置列表的排序
1. marker: 表示一个列表当前排序部分最右边的位置
2. pivot: 表示marker的下一个元素
- 如果该元素的值不小于marker的值，则更新marker
- 反之，则寻找其位置
3. marker

# 7.6 案例研究：维护访问频率

favorites list ADT
- len
- is_empty
- access(e)
- remove(e)
- top(k)

## 7.1 使用有序表
1. 使用PositionalList类作为存储实现一个收藏夹的列表；
2. 使用排序的方法，在每访问一次时，对列表进行一次遍历；


组合模式：定义了一个由两个或两个以上其他对象组成的单一对象。


## 启发式动态调整列表
- 访问局限性：一个元素被访问后，很可能在不久的将来也被访问。
- 启发式算法：每访问一个元素，都将其移动到列表的最前面。

缺点： 当需要访问列表中前k个访问最多的元素时，时间复杂为为O(kn),一旦k与n线性相关，将会变成二次复杂度

# 7.7 基于链表的序列与基于数组的序列

## 基于数组的序列的优点

1. 数组提供时间复杂度为O(1)的基于整数索引的访问一个元素的方法
2. 通常，具有等效边界的操作使用基于数组的结构运行一个常数因子比基于链表的结构运行更有效率
3. 相较于链式结构，基于数组的表示使用存储的比例更少

## 基于链表的序列的优点
1. 基于链表的结构为她们的操作提供最坏情况的时间界限
2. 基于链表的结构支持在任意位置进行时间复杂度为O(1)的插入和删除操作。
