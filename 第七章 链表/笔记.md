# 7.1单向链表
单向链表最简单的实现形式就是由多个节点的集合共同构成一个线性序列。
每个节点含有两个成员：
- 元素成员：引用一个任意的对象。
- 指针域成员：指向单向链表的后继节点。

## 7.1.1使用单向链表实现栈

**代码见**`LinkedStack.py`

操作|运行时间
---|---
S.push(e)|O(1)
S.pop()|O(1)
S.top()|O(1)
len(S)|O(1)
S.is_empty()|O(1)

## 7.1.2 使用单向链表实现队列

**代码见**`LinkedQueue.py`

注意点：
1. 入队列时，需要考虑空队列的特殊情况，此时，队顶、队尾均指向该节点
2. 出队列时，需要考虑，出完之后变成空队列的特殊情况，此时，对尾应该为空

# 7.2 循环链表
在链表中，我们可以使用链表尾部节点的"next"指向链表的头部，由此来获得循环链表。

应用场景：轮转调度

注意点：同单向链表实现队列；

优点：可以快速的实现队首元素出队、再次入队的操作

**代码见**`CircularQueue.py`

# 7.3 双向链表

链表中的每个节点都维护了指向其前驱节点以及后继节点的引用，这样的链表被称为双向链表。

优点：支持更多的时间复杂度为O(1)的操作，包括在任意位置插入和删除节点。

**头哨兵和尾哨兵:**

在列表的起始位置添加头节点(header),在列表的结尾位置添加尾节点(tailer)。这些**不存储主序列的元素**的节点被称为哨兵。

优点：可以使用统一的方式处理所有的插入节点操作。

**双向链表基本类代码见**`_DoublyLinkedBase.py`

## 7.3.2 使用双向链表实现双端队列

# 7.4 位置列表的抽象数据类型
1. 使用整数索引并非一直都很合适
2. 直接使用节点来进行操作会违反了抽象和封装两个面向对象的设计原则

引入一个独立的位置抽象表示列表中一个元素的位置，而不是直接依赖于节点，进而引入一个可以封装双向链表的完整的含位置信息的列表ADT.

- why
- what

## 7.4.1 含位置信息的列表抽象数据结构
- p.element()
- L.first()
- L.last()
- L.before(p)
- L.is_empty()
- len(L)
- iter(L)
- L.add_first(e)
- L.add_last(e)
- L.add_before(p, e)
- L.add_after(p, e)
- L.replace(p, e)
- L.delete(p)

## 7.4.2 双向链表实现
命题 7-2：当使用双向链表实现时，位置列表ADT每个方法的运行时间为最坏情况O(1)

**基于双向链表位置列表 实现代码见**`PositionalList.py`


## 小结
1. 使用位置列表来提供更广泛的操作
2. 通过额外的position类来进行封装

# 7.5 位置列表的排序
1. marker: 表示一个列表当前排序部分最右边的位置
2. pivot: 表示marker的下一个元素
- 如果该元素的值不小于marker的值，则更新marker
- 反之，则寻找其位置
3. marker